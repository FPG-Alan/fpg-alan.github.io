<!DOCTYPE html>
<html lang=zh>
<head>
    <meta charset="utf-8">
    
    <title>MobX 源码学习(二) | Unspecified</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="MobX依赖收集autorun 执行路径之前简单走了一遍MobX的执行流程, 使用的示例只是实现了对某个值的可观察包装, 设立了代理对象和拦截器, 并没有任何观察者, 接下来接着上一篇开头的例子添加一个观察者, 以此来学习MobX中的依赖收集.
123456var test = mobx.observable(&amp;#123;    foo: &apos;bar&apos;&amp;#125;);mobx.autorun(">
<meta property="og:type" content="article">
<meta property="og:title" content="MobX 源码学习(二)">
<meta property="og:url" content="https://fpg-alan.github.io/2017/10/12/mobx-soucercode-study-2/index.html">
<meta property="og:site_name" content="Unspecified">
<meta property="og:description" content="MobX依赖收集autorun 执行路径之前简单走了一遍MobX的执行流程, 使用的示例只是实现了对某个值的可观察包装, 设立了代理对象和拦截器, 并没有任何观察者, 接下来接着上一篇开头的例子添加一个观察者, 以此来学习MobX中的依赖收集.
123456var test = mobx.observable(&amp;#123;    foo: &apos;bar&apos;&amp;#125;);mobx.autorun(">
<meta property="og:updated_time" content="2017-10-13T08:34:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MobX 源码学习(二)">
<meta name="twitter:description" content="MobX依赖收集autorun 执行路径之前简单走了一遍MobX的执行流程, 使用的示例只是实现了对某个值的可观察包装, 设立了代理对象和拦截器, 并没有任何观察者, 接下来接着上一篇开头的例子添加一个观察者, 以此来学习MobX中的依赖收集.
123456var test = mobx.observable(&amp;#123;    foo: &apos;bar&apos;&amp;#125;);mobx.autorun(">
    

    

    
        <link rel="icon" href="/css/images/favicon.ico" />
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">Unspecified</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">首页</a>
                
                    <a class="main-nav-link" href="/archives">存档</a>
                
                    <a class="main-nav-link" href="/categories">分类</a>
                
                    <a class="main-nav-link" href="/tags">标签</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/avatar.jpg" />
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">首页</a></td>
                
                    <td><a class="main-nav-link" href="/archives">存档</a></td>
                
                    <td><a class="main-nav-link" href="/categories">分类</a></td>
                
                    <td><a class="main-nav-link" href="/tags">标签</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/avatar.jpg" />
            <h2 id="name">Alan Yang</h2>
            <h3 id="title">Living is do or die</h3>
            <span id="location"><i class="fa fa-map-marker"></i>Nanjing, China</span>
            <a id="follow" target="_blank" href="https://github.com/FPG-Alan">关注我</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                19
                <span>文章</span>
            </div>
            <div class="article-info-block">
                7
                <span>标签</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://codepen.io/theYY/" target="_blank" title="codepen" class=tooltip>
                            <i class="fa fa-codepen"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main"><article id="post-mobx-soucercode-study-2" class="article article-post article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
            MobX 源码学习(二)
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/10/12/mobx-soucercode-study-2/">
            <time datetime="2017-10-12T08:34:39.000Z" itemprop="datePublished">2017-10-12</time>
        </a>
    </div>


                        
                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/MobX/">MobX</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h3 id="MobX依赖收集"><a href="#MobX依赖收集" class="headerlink" title="MobX依赖收集"></a>MobX依赖收集</h3><h4 id="autorun-执行路径"><a href="#autorun-执行路径" class="headerlink" title="autorun 执行路径"></a>autorun 执行路径</h4><p>之前简单走了一遍MobX的执行流程, 使用的示例只是实现了对某个值的可观察包装, 设立了代理对象和拦截器, 并没有任何观察者, 接下来接着上一篇开头的例子添加一个观察者, 以此来学习MobX中的依赖收集.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> test = mobx.observable(&#123;</div><div class="line">    <span class="attr">foo</span>: <span class="string">'bar'</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">mobx.autorun(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(test.foo)&#125;); <span class="comment">//输出1</span></div><div class="line">test.foo = <span class="number">1</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>autorun方法对一个匿名函数进行包装, 这个匿名函数内存在对一个可观察的值的依赖, 因此成为这个值的观察者, 当这个值改变时, 观察者也被调用, 在控制台打印.</p>
<p>首先找到 autorun 函数:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Creates a named reactive view and keeps it alive, so that the view is always</div><div class="line"> * updated if one of the dependencies changes, even when the view is not further used by something else.</div><div class="line"> * @param name The view name</div><div class="line"> * @param view The reactive view</div><div class="line"> * @param scope (optional)</div><div class="line"> * @returns disposer function, which can be used to stop the view from being updated in the future.</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">autorun</span>(<span class="params"></span></span></div><div class="line">    name: string,</div><div class="line">    view: (r: IReactionPublic) =&gt; <span class="title">any</span>,</div><div class="line">    <span class="title">scope</span>?: <span class="title">any</span></div><div class="line">): <span class="title">IReactionDisposer</span></div><div class="line"><span class="title">export</span> <span class="title">function</span> <span class="title">autorun</span>(<span class="params">arg1: any, arg2: any, arg3?: any</span>) &#123;</div><div class="line">    <span class="keyword">let</span> name: string, <span class="attr">view</span>: <span class="function">(<span class="params">r: IReactionPublic</span>) =&gt;</span> any, <span class="attr">scope</span>: any</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> arg1 === <span class="string">"string"</span>) &#123;</div><div class="line">        name = arg1</div><div class="line">        view = arg2</div><div class="line">        scope = arg3</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        name = arg1.name || <span class="string">"Autorun@"</span> + getNextId()</div><div class="line">        view = arg1</div><div class="line">        scope = arg2</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    invariant(<span class="keyword">typeof</span> view === <span class="string">"function"</span>, getMessage(<span class="string">"m004"</span>))</div><div class="line">    invariant(isAction(view) === <span class="literal">false</span>, getMessage(<span class="string">"m005"</span>))</div><div class="line">    <span class="keyword">if</span> (scope) view = view.bind(scope)</div><div class="line"></div><div class="line">    <span class="keyword">const</span> reaction = <span class="keyword">new</span> Reaction(name, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.track(reactionRunner)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reactionRunner</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        view(reaction)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    reaction.schedule()</div><div class="line"></div><div class="line">    <span class="keyword">return</span> reaction.getDisposer()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数有三个参数, 可以是 &lt; name, view[, scope] &gt;, 也可以是 &lt; view[, scope] &gt;, 当然如果view是箭头函数, 则scope也不需要.<br>函数关键部分在最后几行, 首先初始化了一个 Reaction 的实例, 然后执行 reaction.schedule(), 最后返回 reaction.getDisposer, 下面一点点来看.</p>
<p>首先看看 Reaction 类的注释:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Reactions are a special kind of derivations. Several things distinguishes them from normal reactive computations</div><div class="line"> * Reactions 是一种特殊的 derivations, 他和普通 derivations 有如下几点不同:</div><div class="line"> *</div><div class="line"> * 1) They will always run, whether they are used by other computations or not.</div><div class="line"> * 1) Reactions 总是会运行, 不管他们是不是被其他计算使用. 也就是说, Reactions很适合做一些会触发边际效应的工作, 比如输出控制台, 更新Dom, 进行网络请求.</div><div class="line"> * This means that they are very suitable for triggering side effects like logging, updating the DOM and making network requests.</div><div class="line"> * 2) They are not observable themselves</div><div class="line"> * 2) Reactions 不会观察自己.</div><div class="line"> * 3) They will always run after any 'normal' derivations</div><div class="line"> * 3) Reactions 总会在任何普通 derivations 之后运行.</div><div class="line"> * 4) They are allowed to change the state and thereby triggering themselves again, as long as they make sure the state propagates to a stable state in a reasonable amount of iterations.</div><div class="line"> * 4) Reactions 允许更改状态从而再次触发自身, 只要能够确保状态在一定次数的迭代后能达到稳态.</div><div class="line"> *</div><div class="line"> * The state machine of a Reaction is as follows:</div><div class="line"> * 一个 Reaction 的状态机如下:</div><div class="line"> *</div><div class="line"> * 1) after creating, the reaction should be started by calling `runReaction` or by scheduling it (see also `autorun`)</div><div class="line"> * 1) 被生成后, 应该从 `runReaction` 或 `schedule` 启动</div><div class="line"> * 2) the `onInvalidate` handler should somehow result in a call to `this.track(someFunction)`</div><div class="line"> * 2) `onInvalidate`函数应该由 `this.track(someFunction)` 触发</div><div class="line"> * 3) all observables accessed in `someFunction` will be observed by this reaction.</div><div class="line"> * 3) 所有在 autorun 包装的函数中访问的 observables 的值都会被这个 reaction 观察.</div><div class="line"> * 4) as soon as some of the dependencies has changed the Reaction will be rescheduled for another run (after the current mutation or transaction). `isScheduled` will yield true once a dependency is stale and during this period</div><div class="line"> * 4) 一旦某些依赖(observing 数组中的 observables)改变, Reaction 会被重新安排到另一次运行进程(在当前 mutation 或 transaction 之后). 这个过程中, 一旦一个依赖过期, `isScheduled` 会变为 true </div><div class="line"> * 5) `onInvalidate` will be called, and we are back at step 1.</div><div class="line"> * 5) `onInvalidate` 被调用, 回到 step 1.</div><div class="line"> *</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<p>这是 reaction.schedule的执行路径:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">schedule() &#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._isScheduled) &#123;</div><div class="line">        <span class="keyword">this</span>._isScheduled = <span class="literal">true</span></div><div class="line">        globalState.pendingReactions.push(<span class="keyword">this</span>)</div><div class="line">        runReactions()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">runReactions</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// Trampolining, if runReactions are already running, new reactions will be picked up</span></div><div class="line">    <span class="keyword">if</span> (globalState.inBatch &gt; <span class="number">0</span> || globalState.isRunningReactions) <span class="keyword">return</span></div><div class="line">    reactionScheduler(runReactionsHelper)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">runReactionsHelper</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    globalState.isRunningReactions = <span class="literal">true</span></div><div class="line">    <span class="keyword">const</span> allReactions = globalState.pendingReactions</div><div class="line">    <span class="keyword">let</span> iterations = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="comment">// While running reactions, new reactions might be triggered.</span></div><div class="line">    <span class="comment">// Hence we work with two variables and check whether</span></div><div class="line">    <span class="comment">// we converge to no remaining reactions after a while.</span></div><div class="line">    <span class="keyword">while</span> (allReactions.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (++iterations === MAX_REACTION_ITERATIONS) &#123;</div><div class="line">            <span class="built_in">console</span>.error(</div><div class="line">                <span class="string">`Reaction doesn't converge to a stable state after <span class="subst">$&#123;MAX_REACTION_ITERATIONS&#125;</span> iterations.`</span> +</div><div class="line">                    <span class="string">` Probably there is a cycle in the reactive function: <span class="subst">$&#123;allReactions[<span class="number">0</span>]&#125;</span>`</span></div><div class="line">            )</div><div class="line">            allReactions.splice(<span class="number">0</span>) <span class="comment">// clear reactions</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">let</span> remainingReactions = allReactions.splice(<span class="number">0</span>)</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = remainingReactions.length; i &lt; l; i++)</div><div class="line">            remainingReactions[i].runReaction()</div><div class="line">    &#125;</div><div class="line">    globalState.isRunningReactions = <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">runReaction() &#123;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isDisposed) &#123;</div><div class="line">            startBatch()</div><div class="line">            <span class="keyword">this</span>._isScheduled = <span class="literal">false</span></div><div class="line">            <span class="keyword">if</span> (shouldCompute(<span class="keyword">this</span>)) &#123;</div><div class="line">                <span class="keyword">this</span>._isTrackPending = <span class="literal">true</span></div><div class="line"></div><div class="line">                <span class="keyword">this</span>.onInvalidate()</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>._isTrackPending &amp;&amp; isSpyEnabled()) &#123;</div><div class="line">                    ...</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            endBatch()</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到这是一个批量执行的过程, schedule 将当前 reaction 压入 globalState.pendingReactions 数组, runReactions 则判断当前是否正在执行<br> runReactions, 如果空闲则开始 runReactionsHelper, 这个函数内通过 let remainingReactions = allReactions.splice(0) 来动态获取可能在执行过程中新压入的 reaction,循环执行所有 reaction 上的 runReaction 方法.<br>在批量执行的过程中, 还通过设置 MAX_REACTION_ITERATIONS (最大迭代数)来避免可能存在的死循环(被包装函数内修改状态-&gt;重新引发reaction).</p>
<p>下面到 runReaction 方法内, 先不看 startBatch 和 endBatch, 以及调试和Spy部分, 核心是 onInvalidate 函数, 这个函数是在实例化 Reaction 对象时通过构造函数传递进来的匿名函数:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.track(reactionRunner)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactionRunner</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    view(reaction) </div><div class="line">    <span class="comment">// 这里view函数是使用autorun包装的那个匿名函数:</span></div><div class="line">    <span class="comment">// ()=&gt;&#123;console.log(test.foo)&#125;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">track(fn: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span>) &#123;</div><div class="line">    startBatch()</div><div class="line">    <span class="keyword">const</span> notify = isSpyEnabled()</div><div class="line">    <span class="keyword">let</span> startTime</div><div class="line">    <span class="keyword">if</span> (notify) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>._isRunning = <span class="literal">true</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> result = trackDerivedFunction(<span class="keyword">this</span>, fn, <span class="literal">undefined</span>)</div><div class="line"></div><div class="line">    <span class="keyword">this</span>._isRunning = <span class="literal">false</span></div><div class="line">    <span class="keyword">this</span>._isTrackPending = <span class="literal">false</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isDisposed) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (isCaughtException(result)) ...</div><div class="line">    if (notify) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    endBatch()</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>根据执行路径直接看到 track 函数内部, 发现剔除 start/endBatch, 调试报错相关的代码, 转到 trackDerivedFunction 函数:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Executes the provided function `f` and tracks which observables are being accessed.</div><div class="line"> * The tracking information is stored on the `derivation` object and the derivation is registered</div><div class="line"> * as observer of any of the accessed observables.</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">trackDerivedFunction</span>&lt;<span class="title">T</span>&gt;(<span class="params">derivation: IDerivation, f: (</span>) =&gt; <span class="title">T</span>, <span class="title">context</span>) </span>&#123;</div><div class="line">    <span class="comment">// pre allocate array allocation + room for variation in deps</span></div><div class="line">    <span class="comment">// array will be trimmed by bindDependencies</span></div><div class="line">    changeDependenciesStateTo0(derivation)</div><div class="line">    derivation.newObserving = <span class="keyword">new</span> <span class="built_in">Array</span>(derivation.observing.length + <span class="number">100</span>)</div><div class="line">    derivation.unboundDepsCount = <span class="number">0</span></div><div class="line">    derivation.runId = ++globalState.runId</div><div class="line">    <span class="keyword">const</span> prevTracking = globalState.trackingDerivation</div><div class="line">    globalState.trackingDerivation = derivation</div><div class="line">    <span class="keyword">let</span> result</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        result = f.call(context)</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        result = <span class="keyword">new</span> CaughtException(e)</div><div class="line">    &#125;</div><div class="line">    globalState.trackingDerivation = prevTracking</div><div class="line">    bindDependencies(derivation)</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>首先看参数, reaction 中的trackDerivedFunction 传递过来的 this 在这个函数签名中显示为 derivation, 这没问题, 因为 Reaction 实现了 IDerivation 和 IReactionPublic 两个接口, 也即 reaction 是 derivation 的一种.</p>
<p>changeDependenciesStateTo0 函数暂时不看(不懂), 下面几行设置一些属性, 然后把当前 derivation 对象设置为 globalState.trackingDerivation, 接下来就开始运行使用 autorun 包装的匿名函数了.<br>这之后, 把 globalState.trackingDerivation 重置成原始值, 并执行 bindDependencies(derivation).</p>
<p>先不看 bindDependencies 函数, 理一下思路, autorun 包装的函数实际上到这表现为一个 reaction(derivation)对象, 这个对象在执行被包装的函数时, 会通过某种机制收集所有依赖存入自己的 observing 属性, 其实也就是被包装函数内所有访问到的, 可被观察的值, 这些值都是 observablevalue 的实例对象.<br>同时也会把自身注册到这些依赖的 observers 属性内, 这样来完成一个双向绑定, 而在 observablevalue 对象的Set拦截器中应该也有某种机制, 把这个改变传递给所有的 observers(reaction), 这里应该就是重新运行 reaction.schedule (?)</p>
<p>所以接下来, 需要弄明白的问题就是:</p>
<ol>
<li>双向绑定各自在什么位置发生</li>
<li>Set拦截器到 reaction.schedule 的执行路径.</li>
</ol>
<hr>
<h4 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h4><p>首先看上面执行路径的最后一步, trackDerivedFunction, 在这个函数内调用了被 autorun 包装的函数, 本例中是:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">()=&gt;&#123;<span class="built_in">console</span>.log(test.foo)&#125;</div></pre></td></tr></table></figure><br>在这之前, test.foo 被包装成了一个 observablevalue, 因此这里当访问 test.foo 时将会触发Get拦截器:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public get(): T &#123;</div><div class="line">    <span class="keyword">this</span>.reportObserved()</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dehanceValue(<span class="keyword">this</span>.value)</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reportObserved</span>(<span class="params">observable: IObservable</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> derivation = globalState.trackingDerivation</div><div class="line">    <span class="keyword">if</span> (derivation !== <span class="literal">null</span>) &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">		 * Simple optimization, give each derivation run an unique id (runId)</div><div class="line">		 * Check if last time this observable was accessed the same runId is used</div><div class="line">		 * if this is the case, the relation is already known</div><div class="line">		 */</div><div class="line">        <span class="keyword">if</span> (derivation.runId !== observable.lastAccessedBy) &#123;</div><div class="line">            observable.lastAccessedBy = derivation.runId</div><div class="line">            derivation.newObserving![derivation.unboundDepsCount++] = observable</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (observable.observers.length === <span class="number">0</span>) &#123;</div><div class="line">        queueForUnobservation(observable)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么这里的 derivation 就是上面设定的 derivation, 接下来进入条件判断, 这里应该是满足第一个条件, 然后是一个性能优化, 判断当前 observablevalue 的 lastAccessedBy 属性和 derivation.runId 属性是否相同, 如果相同则说明这个 observablevalue 已经被当前 derivation 收集. 比如在一个 autorun 包装函数内多次访问同一个 observablevalue, 这样可以避免重复收集依赖带来的性能损耗.<br>接着就是简单的设置 observablevalue.lastAccessedBy 属性值为当前 derivation.runId, 然后把这个 observablevalue 压入当前 derivation.newObserving 内, 同时 derivation.unboundDepsCount 自增.<br>此时并没有进行任何绑定, 接下来回到 trackDerivedFunction, 在调用包装函数后, 调用 bindDependencies:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * diffs newObserving with observing.</div><div class="line"> * update observing to be newObserving with unique observables</div><div class="line"> * notify observers that become observed/unobserved</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindDependencies</span>(<span class="params">derivation: IDerivation</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> prevObserving = derivation.observing</div><div class="line">    <span class="keyword">const</span> observing = (derivation.observing = derivation.newObserving!)</div><div class="line">    <span class="keyword">let</span> lowestNewObservingDerivationState = IDerivationState.UP_TO_DATE</div><div class="line"></div><div class="line">    derivation.newObserving = <span class="literal">null</span> <span class="comment">// newObserving shouldn't be needed outside tracking</span></div><div class="line"></div><div class="line">    <span class="comment">// Go through all new observables and check diffValue: (this list can contain duplicates):</span></div><div class="line">    <span class="comment">//   0: first occurrence, change to 1 and keep it</span></div><div class="line">    <span class="comment">//   1: extra occurrence, drop it</span></div><div class="line">    <span class="keyword">let</span> i0 = <span class="number">0</span>,</div><div class="line">        l = derivation.unboundDepsCount</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</div><div class="line">        <span class="keyword">const</span> dep = observing[i]</div><div class="line">        <span class="keyword">if</span> (dep.diffValue === <span class="number">0</span>) &#123;</div><div class="line">            dep.diffValue = <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> (i0 !== i) observing[i0] = dep</div><div class="line">            i0++</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined,</span></div><div class="line">        <span class="comment">// not hitting the condition</span></div><div class="line">        <span class="keyword">if</span> (((dep <span class="keyword">as</span> any) <span class="keyword">as</span> IDerivation).dependenciesState &gt; lowestNewObservingDerivationState) &#123;</div><div class="line">            lowestNewObservingDerivationState = ((dep <span class="keyword">as</span> any) <span class="keyword">as</span> IDerivation).dependenciesState</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    observing.length = i0</div><div class="line"></div><div class="line">    <span class="comment">// Go through all old observables and check diffValue: (it is unique after last bindDependencies)</span></div><div class="line">    <span class="comment">//   0: it's not in new observables, unobserve it</span></div><div class="line">    <span class="comment">//   1: it keeps being observed, don't want to notify it. change to 0</span></div><div class="line">    l = prevObserving.length</div><div class="line">    <span class="keyword">while</span> (l--) &#123;</div><div class="line">        <span class="keyword">const</span> dep = prevObserving[l]</div><div class="line">        <span class="keyword">if</span> (dep.diffValue === <span class="number">0</span>) &#123;</div><div class="line">            removeObserver(dep, derivation)</div><div class="line">        &#125;</div><div class="line">        dep.diffValue = <span class="number">0</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Go through all new observables and check diffValue: (now it should be unique)</span></div><div class="line">    <span class="comment">//   0: it was set to 0 in last loop. don't need to do anything.</span></div><div class="line">    <span class="comment">//   1: it wasn't observed, let's observe it. set back to 0</span></div><div class="line">    <span class="keyword">while</span> (i0--) &#123;</div><div class="line">        <span class="keyword">const</span> dep = observing[i0]</div><div class="line">        <span class="keyword">if</span> (dep.diffValue === <span class="number">1</span>) &#123;</div><div class="line">            dep.diffValue = <span class="number">0</span></div><div class="line">            addObserver(dep, derivation)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Some new observed derivations might become stale during this derivation computation</span></div><div class="line">    <span class="comment">// so say had no chance to propagate staleness (#916)</span></div><div class="line">    <span class="keyword">if</span> (lowestNewObservingDerivationState !== IDerivationState.UP_TO_DATE) &#123;</div><div class="line">        derivation.dependenciesState = lowestNewObservingDerivationState</div><div class="line">        derivation.onBecomeStale()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>嗯….看起来,这里就是真正进行依赖收集的地方了, 来仔细看看:</p>
<ol>
<li>首先是保存当前 derivation 的 observing, 这是已经收集的依赖, 如果是第一次运行应该是空.</li>
<li>把 newObserving 赋值给 observing, 这里都是新收集的依赖</li>
<li>lowestNewObservingDerivationState 暂时跳过</li>
<li>newObserving 销毁, 之后不再需要了</li>
<li>遍历 observing, 通过每个依赖的 diffValue 判断是否重复, 这一趟循环主要是去重</li>
<li>接下来遍历 prevObserving, 这是上一次收集的依赖, 如果某个依赖的 diffValue 为0, 证明这个依赖在本次收集中不在存在, 则需要清除, 而其他的旧依赖则把 diffValue 置 0</li>
<li>接下来重新遍历 observing, 经过Step6的遍历, 凡是 diffValue 为0的表示属于之前收集的依赖, 已经建立过绑定, 本次就不需要再进行额外操作, 而其他依赖则属于新收集到的依赖, 需要进行绑定<br>最后是对当前 derivation 可能在进行本次执行中已经过期的处理, 这里暂时跳过, 目前还不是很清楚.</li>
</ol>
<p>5-7的三个循环很巧妙的通过 diffValue 筛选出 [<code>新收集的</code> <code>未绑定的</code>] 和 [<code>之前收集的</code> <code>本次未收集到的</code>]两种依赖, 分别进行 addObserver 和 removeObserver.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addObserver</span>(<span class="params">observable: IObservable, node: IDerivation</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> l = observable.observers.length</div><div class="line">    <span class="keyword">if</span> (l) &#123;</div><div class="line">        <span class="comment">// because object assignment is relatively expensive, let's not store data about index 0.</span></div><div class="line">        observable.observersIndexes[node.__mapid] = l</div><div class="line">    &#125;</div><div class="line">    observable.observers[l] = node</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (observable.lowestObserverState &gt; node.dependenciesState)</div><div class="line">        observable.lowestObserverState = node.dependenciesState</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>这里基本上就是把当前 derivation 压入依赖(observablevalue)的 observers 数组.</p>
<p>removeObserver 略复杂一点, 主要应该基于性能考虑, 但基本上相当于把当前 derivation 从依赖的 observers 数组中移除.</p>
<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>当某个值被包装为 observablevalue 之后, 它的Set/Get都被拦截, 如果有一个使用 autorun 包装的函数或者说一个 derivation 使用到某个 observablevalue 后, 两者之间就会建立一种绑定, 使得一旦 observablevalue 发生改变, derivation 就会被调用, 也就是 derivation 成为 observablevalue 的观察者.<br>这个过程中, derivation 观察的 observablevalue 也就是 derivation 的依赖, 如何收集这些依赖则是形成这种观察者模式里面非常重要的部分.</p>
<p>derivation 是通过 observablevalue 的 Get拦截器来进行依赖收集的, derivation 一旦访问某个 observablevalue, 在这个值的Get拦截器中, [<code>他会把自己加入到 derivation 的observing 数组</code>], 而在 derivation 包装函数执行结束后, derivation 会遍历自己的 observing 属性, [<code>将自身注册到每个 observablevalue 的 observers 属性中</code>].</p>
<p>依赖收集这部分现在清楚了一点, 这么看来, observablevalue 的Set拦截器内会遍历 observers 属性, 并执行其中保存的每个 derivation, 这里我还有两个疑问:</p>
<ol>
<li>observablevalue 和 derivation 之间应该是多对多的关系, 如果某个 derivation 的多个依赖在某个调用栈内进行了多次Set拦截, 这个 derivation 会执行多次吗</li>
<li>derivation 内为何要保存收集的依赖?</li>
</ol>
<p>接下来我会看看Set拦截器究竟做了什么.</p>

        
        </div>
        
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="https://fpg-alan.github.io/2017/10/12/mobx-soucercode-study-2/" data-id="cj8o7povv000qedj7n346dou8" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
        
<nav id="article-nav">
    
    
        <a href="/2017/10/12/mobx-sourcecode-study/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">下一篇</strong>
            <div class="article-nav-title">MobX 源码学习(一)</div>
        </a>
    
</nav>


    
</article>




    
   
    
   

</section>
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2017/10/12/mobx-soucercode-study-2/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2017/10/12/mobx-soucercode-study-2/" class="title">MobX 源码学习(二)</a></p>
                            <p class="item-date"><time datetime="2017-10-12T08:34:39.000Z" itemprop="datePublished">2017-10-12</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2017/10/12/mobx-sourcecode-study/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2017/10/12/mobx-sourcecode-study/" class="title">MobX 源码学习(一)</a></p>
                            <p class="item-date"><time datetime="2017-10-12T02:51:13.000Z" itemprop="datePublished">2017-10-12</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2017/09/25/Jank-Busting-for-Better-Rendering-Performance/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2017/09/25/Jank-Busting-for-Better-Rendering-Performance/" class="title">Jank Busting for Better Rendering Performance</a></p>
                            <p class="item-date"><time datetime="2017-09-25T07:26:05.000Z" itemprop="datePublished">2017-09-25</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2017/05/01/nerual-network/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2017/05/01/nerual-network/" class="title">神经网络学习总结</a></p>
                            <p class="item-date"><time datetime="2017-05-01T02:35:54.000Z" itemprop="datePublished">2017-05-01</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2017/03/23/basic-http/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2017/03/23/basic-http/" class="title">从输入地址到获取页面详细过程</a></p>
                            <p class="item-date"><time datetime="2017-03-23T08:29:59.000Z" itemprop="datePublished">2017-03-23</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    
        
    <div class="widget-wrap">
        <h3 class="widget-title">归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">十一月 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">十月 2014</a><span class="archive-list-count">8</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">标签</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Drupal/">Drupal</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MobX/">MobX</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Performance/">Performance</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript-nodejs/">javascript nodejs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nerual-network/">nerual network</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/technology-stack/">technology stack</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">标签云</h3>
        <div class="widget tagcloud">
            <a href="/tags/Drupal/" style="font-size: 20px;">Drupal</a> <a href="/tags/MobX/" style="font-size: 15px;">MobX</a> <a href="/tags/Performance/" style="font-size: 10px;">Performance</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/javascript-nodejs/" style="font-size: 10px;">javascript nodejs</a> <a href="/tags/nerual-network/" style="font-size: 10px;">nerual network</a> <a href="/tags/technology-stack/" style="font-size: 10px;">technology stack</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">链接</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://hexo.io">Hexo</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2017 AlanYang<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        <!-- 
 -->

    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>